#!/usr/bin/env bash -e

function usage() {
  cat <<EOF
USAGE:
  $(basename -- $0) [OPTION] <dir>

OPTIONS:
  --absolute                Provide the absolute path (default).
  --basename                Provide the filename from a path.
  --dereference             Dereference a link all the way down to it's source.
  --dirname                 Provide the dirname from a path.
  --help                    This help.
  --scm-root                Find the scm root (git or hg).

EOF
  exit 0
}

function __strip_extraneous_slashes() {
  read <<< $@
  echo "${@:-$(cat /dev/stdin)}" | sed -E 's#/+#/#g'
}

function __dereference() {
  read <<< $@
  working_dir=$(dirname ${@:-$(cat /dev/stdin)})
  path=$(readlink ${@:-$(cat /dev/stdin)} || echo $@)
  count=0

  while [[ -L ${path} ]]; do
    if [[ ${count} -gt 30 ]]; then
      fatal "Symlink loop."
    else
      path=$(readlink ${path})
      count=$(( ${count} + 1 ))
    fi
  done

  pushd ${working_dir} > /dev/null
  __clean_path ${path}
  popd > /dev/null
}

function __qualify_dot_dot_slashes() {
  read <<< $@
  stdin=$(cat /dev/stdin)

  if [[ -d ${stdin} ]] && [[ ! -L ${stdin} ]]; then
    dir=${stdin}
  else
    dir=$(dirname -- "${stdin}")
    file=$(basename -- "${stdin}")
  fi

  cd "${dir}"
  echo $(pwd)/${file}
}

function __clean_path() {
  read <<< $@
  echo ${@:-$(cat /dev/stdin)} | __qualify_dot_dot_slashes | __strip_extraneous_slashes
}

function __dirname() {
  read <<< $@
  in=${@:-$(cat /dev/stdin)}
  if [[ -d $in ]]; then
    __clean_path $in
  else
    dirname -- $in | __clean_path
  fi
}

function __filename() {
  [[ -e $1 ]] && [[ ! -d $1 ]] || fatal "Path isn't to a file"
  basename -- $(__clean_path $1)
}

function __scm_dir() {
  [[ -d "$1/.hg" || -d "$1/.git" ]] && return 0
}

function __scm_root() {
  dereferenced_file=$($0 --dereference $1)
  dir=$(__dirname ${dereferenced_file})
  until [[ ${dir} == "/" ]]; do
    if __scm_dir ${dir}; then
      __clean_path ${dir}
      return 0
    fi

    dir="$(__clean_path ${dir}/../)"
  done

  fatal "SCM dir not found"
}

function fatal() {
  echo "Fatal: $1" > /dev/stderr
  exit 1
}

[[ -z $@ ]] && usage
PATH_ARGS=""
OPTION="--absolute"
PATH_ARGS=()

for a in "$@"; do
  if [[ -e "$a" ]] || [[ -L "$a" ]]; then
    PATH_ARGS+=( "$(__clean_path $a)" )
  elif [[ "$a" =~ ^--[a-z\-]+$ ]]; then
    OPTION=$a
  fi
done

for element in $(seq 0 $((${#PATH_ARGS[@]} - 1))); do
  path=${PATH_ARGS[$element]}
  [[ -z ${path} ]] && break

  case "${OPTION}" in
    "--absolute")             echo $path                    ;;
    "--basename")             [[ ! -d $path ]] && __filename $path  ;;
    "--dereference")          __dereference $path                   ;;
    "--dirname")              __dirname $path                       ;;
    "--scm"|"--scm-root")     __scm_root $path                      ;;
  esac
done

case "${OPTION}" in
  "--help")                   usage                                 ;;
esac
