#!/usr/bin/env bash -e
function usage() {
  cat <<EOF
USAGE:
  $(basename -- $0) [OPTION] <dir>

OPTIONS:
  -a, --absolute            Absolute path (default).
  -b, --basename            Strip directory from path.
  -D, --dereference         Recursively find the ultimate target of a symlink.
  -d, --dirname             Strip file from path.
  -h, --help                This help.
  -s, --scm-root            Find the SCM root (git or hg) for file.

EOF
  exit 0
}

function __strip_extraneous_slashes() {
  echo "$@" | sed -E 's#/+#/#g'
}

function __dereference() {
  working_dir=$(dirname -- $@)
  path=$(readlink -- $@ || echo $@)
  count=0

  while [[ -L "${path}" ]]; do
    if [[ ${count} -gt 30 ]]; then
      fatal "Symlink loop."
    else
      path=$(readlink "${path}")
      count=$(( ${count} + 1 ))
    fi
  done

  pushd "${working_dir}" > /dev/null
  __clean_path "${path}"
  popd > /dev/null
}

function __qualify_dot_dot_slashes() {
  if [[ -d "${path}" ]] && [[ ! -L ${path} ]]; then
    dir=$@
  else
    dir=$(dirname -- "${path}")
    file=$(basename -- "${path}")
  fi

  pushd "${dir}" &> /dev/null
  echo $(pwd)/${file}
  popd &> /dev/null
}

function __set_trailing_slash() {
  path=$@
  if [[ ${path} != "/" ]]; then
    # strip slash before testing.
    path=$(echo ${path} | sed -E 's#\/?$##')
    if [[ -d "${path}" ]] && [[ ! -L "${path}" ]]; then
      # make sure it has a trailing slash
      path=$(echo ${path} | sed -E 's#\/?$#/#')
    else
      # make sure it does not have a trailing slash
      path=$(echo ${path} | sed -E 's#\/?$##')
    fi
  fi
  echo ${path}
}


function __clean_path() {
  path=$@
  path=$(__expand_tilde "${path}")
  path=$(__qualify_dot_dot_slashes "${path}")
  path=$(__strip_extraneous_slashes "${path}")
  path=$(__set_trailing_slash "${path}")
  echo ${path}
}

function __dirname() {
  path=$(__clean_path $@)
  if [[ ! -d "${path}" ]]; then
    path=$(dirname -- "${path}")
    if [[ $? -ne 0 ]]; then
      echo "Fatal: dirname isn't happy with ${path}" > /dev/stderr
      exit 1
    fi
  fi
  __clean_path "${path}"
}

function __filename() {
  [[ -e $1 ]] && [[ ! -d $1 ]] || fatal "Path isn't to a file"
  basename -- $(__clean_path "$1")
}

function __scm_dir() {
  [[ -d "$1/.hg" || -d "$1/.git" ]] && return 0
}

function __scm_root() {
  dereferenced_file=$($0 --dereference $1)
  dir=$(__dirname ${dereferenced_file})
  until [[ ${dir} == "/" ]]; do
    if __scm_dir "${dir}"; then
      __clean_path "${dir}"
      return 0
    fi

    dir="$(__clean_path "${dir}/../")"
  done

  fatal "SCM dir not found"
}

function fatal() {
  echo "Fatal: $1" > /dev/stderr
  exit 1
}

function __user_home() {
  user=$1
  if [[ $(uname) == "Darwin" ]]; then
    dscacheutil -q user -a name ${user} | grep ^dir: | cut -d\  -f2-
  else
    cat /etc/passwd | grep ^${user} | cut -d: -f6
  fi
}

function __expand_tilde() {
  path=$1

  user_section=$(echo ${path} | grep -o '^~[^\/]*')
  path_section=$(echo ${path} | grep -o '\/.*$')

  if [[ -z ${user_section} ]]; then
    echo ${path}
    return 0
  elif [[ ${user_section} == "~" ]]; then
    user=${USER}
  else
    user=$(echo ${user_section} | sed 's/~//g')
  fi

  echo "$(__user_home ${user})${path_section}"
}

[[ -z $@ ]] && usage
PATH_ARGS=""
OPTION="--absolute"
PATH_ARGS=()

for i in $(seq 1 $#); do
  eval a=\$$i

  a=$(__expand_tilde "$a")
  if [[ -e "$a" ]] || [[ -L "$a" ]]; then
    PATH_ARGS+=( "$(__clean_path "$a")" )
  elif [[ "$a" =~ ^--[a-z\-]+$ ]]; then
    OPTION=$a
  elif [[ "$a" =~ ^-[a-z]$ ]]; then
    OPTION=$a
  fi
done

if [[ -p /dev/stdin ]]; then
  PATH_ARGS+=( "$(__clean_path $(cat /dev/stdin))" )
fi

for element in $(seq 0 $((${#PATH_ARGS[@]} - 1))); do
  path=${PATH_ARGS[$element]}
  [[ -z "${path}" ]] && break

  case "${OPTION}" in
    "--absolute"|"-a")             echo "$path"                              ;;
    "--basename"|"-b")             [[ ! -d "$path" ]] && __filename "$path"  ;;
    "--dereference"|"-D")          __dereference "$path"                     ;;
    "--dirname"|"-d")              __dirname "$path"                         ;;
    "--scm"|"--scm-root"|"-s")     __scm_root "$path"                        ;;
  esac
done

case "${OPTION}" in
  "--help")                   usage                                 ;;
esac
