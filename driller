#!/usr/bin/env bash -e
function usage() {
  cat <<EOF
USAGE:
  $(basename -- $0) [OPTION] <dir>

OPTIONS:
  -a, --absolute            Provide the absolute path (default).
  -b, --basename            Provide the filename from a path.
  -D, --dereference         Dereference a link all the way down to it's source.
  -d, --dirname             Provide the dirname from a path.
  -h, --help                This help.
  -s, --scm-root            Find the scm root (git or hg).

EOF
  exit 0
}

function __strip_extraneous_slashes() {
  read <<< $@
  echo "${@:-$(cat /dev/stdin)}" | sed -E 's#/+#/#g'
}

function __dereference() {
  read <<< $@
  working_dir=$(dirname ${@:-$(cat /dev/stdin)})
  path=$(readlink ${@:-$(cat /dev/stdin)} || echo $@)
  count=0

  while [[ -L ${path} ]]; do
    if [[ ${count} -gt 30 ]]; then
      fatal "Symlink loop."
    else
      path=$(readlink ${path})
      count=$(( ${count} + 1 ))
    fi
  done

  pushd ${working_dir} > /dev/null
  __clean_path ${path}
  popd > /dev/null
}

function __qualify_dot_dot_slashes() {
  read <<< $@
  stdin=$(cat /dev/stdin)

  if [[ -d ${stdin} ]] && [[ ! -L ${stdin} ]]; then
    dir=${stdin}
  else
    dir=$(dirname -- "${stdin}")
    file=$(basename -- "${stdin}")
  fi

  cd "${dir}"
  echo $(pwd)/${file}
}

function __clean_path() {
  read <<< $@
  echo ${@:-$(cat /dev/stdin)} | __qualify_dot_dot_slashes | __strip_extraneous_slashes
}

function __dirname() {
  read <<< $@
  in=${@:-$(cat /dev/stdin)}
  if [[ -d $in ]]; then
    __clean_path $in
  else
    dirname -- $in | __clean_path
  fi
}

function __filename() {
  [[ -e $1 ]] && [[ ! -d $1 ]] || fatal "Path isn't to a file"
  basename -- $(__clean_path $1)
}

function __scm_dir() {
  [[ -d "$1/.hg" || -d "$1/.git" ]] && return 0
}

function __scm_root() {
  dereferenced_file=$($0 --dereference $1)
  dir=$(__dirname ${dereferenced_file})
  until [[ ${dir} == "/" ]]; do
    if __scm_dir ${dir}; then
      __clean_path ${dir}
      return 0
    fi

    dir="$(__clean_path ${dir}/../)"
  done

  fatal "SCM dir not found"
}

function fatal() {
  echo "Fatal: $1" > /dev/stderr
  exit 1
}

function __user_home() {
  user=$1
  if [[ $(uname) == "Darwin" ]]; then
    dscacheutil -q user -a name ${user} | grep ^dir: | cut -d\  -f2-
  else
    cat /etc/passwd | grep ^${user} | cut -d: -f6
  fi
}

function __expand_tilde() {
  path=$1

  user_section=$(echo ${path} | grep -o '^~[^\/]*')
  path_section=$(echo ${path} | grep -o '\/.*$')

  if [[ -z ${user_section} ]]; then
    echo ${path}
    return 0
  elif [[ ${user_section} == "~" ]]; then
    user=${USER}
  else
    user=$(echo ${user_section} | sed 's/~//g')
  fi

  echo "$(__user_home ${user})${path_section}"
}

[[ -z $@ ]] && usage
PATH_ARGS=""
OPTION="--absolute"
PATH_ARGS=()

arguments="$@"
[[ -p /dev/stdin ]] && arguments="$arguments $(cat /dev/stdin)"

for a in ${arguments}; do
  a=$(__expand_tilde $a)
  if [[ -e "$a" ]] || [[ -L "$a" ]]; then
    PATH_ARGS+=( "$(__clean_path $a)" )
  elif [[ "$a" =~ ^--[a-z\-]+$ ]]; then
    OPTION=$a
  elif [[ "$a" =~ ^-[a-z]$ ]]; then
    OPTION=$a
  fi
done

for element in $(seq 0 $((${#PATH_ARGS[@]} - 1))); do
  path=${PATH_ARGS[$element]}
  [[ -z ${path} ]] && break

  case "${OPTION}" in
    "--absolute"|"-a")             echo $path                            ;;
    "--basename"|"-b")             [[ ! -d $path ]] && __filename $path  ;;
    "--dereference"|"-D")          __dereference $path                   ;;
    "--dirname"|"-d")              __dirname $path                       ;;
    "--scm"|"--scm-root"|"-s")     __scm_root $path                      ;;
  esac
done

case "${OPTION}" in
  "--help")                   usage                                 ;;
esac
